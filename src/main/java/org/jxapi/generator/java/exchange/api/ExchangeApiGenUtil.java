package org.jxapi.generator.java.exchange.api;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.UnaryOperator;

import org.apache.commons.lang3.StringUtils;
import org.jxapi.exchange.ExchangeApi;
import org.jxapi.exchange.descriptor.gen.ExchangeApiDescriptor;
import org.jxapi.exchange.descriptor.gen.ExchangeDescriptor;
import org.jxapi.exchange.descriptor.gen.RestEndpointDescriptor;
import org.jxapi.exchange.descriptor.gen.WebsocketEndpointDescriptor;
import org.jxapi.exchange.descriptor.gen.WebsocketTopicMatcherDescriptor;
import org.jxapi.generator.java.Imports;
import org.jxapi.generator.java.JavaCodeGenUtil;
import org.jxapi.generator.java.exchange.ExchangeGenUtil;
import org.jxapi.generator.java.pojo.PojoGenUtil;
import org.jxapi.netutils.rest.HttpMethod;
import org.jxapi.netutils.websocket.multiplexing.WSMTMFUtil;
import org.jxapi.netutils.websocket.multiplexing.WebsocketMessageTopicMatcherFactory;
import org.jxapi.pojo.descriptor.CanonicalType;
import org.jxapi.pojo.descriptor.Field;
import org.jxapi.pojo.descriptor.Type;
import org.jxapi.util.CollectionUtil;
import org.jxapi.util.EncodingUtil;
import org.jxapi.util.JsonUtil;
import org.jxapi.util.PlaceHolderResolver;

/**
 * Helper static methods around generation of {@link ExchangeApi} java classes implementation.
 */
public class ExchangeApiGenUtil {
  
  private static final String INVALID_TOPIC_MATCHER_FOR_WEBSOCKET_ENDPOINT = "Invalid topic matcher for websocket endpoint:";

  private static final String OF_EXCHANGE = " of exchange:";

  private static final String OF_EXCHANGE_API = " of exchange API:";
  
  public static final String RAW_BODY_REST_REQUEST_ARG_NAME = "body";

  private ExchangeApiGenUtil() {}
  
  /**
   * Default name for request argument
   */
  public static final String DEFAULT_REQUEST_ARG_NAME = "request";
  
  /**
   * Suffix for REST endpoint API interface variable name. The actual variable
   * name is generated by prepending the endpoint name with this suffix converted
   * to upper case 'static' variable name.
   */
  public static final String REST_ENDPOINT_NAME_SUFFIX = "RestApi";
  
  /**
   * Suffix for Websocket endpoint API interface variable name. The actual
   * variable name is generated by prepending the endpoint name with this suffix
   * converted to upper case 'static' variable name.
   */
  public static final String WEBSOCKET_ENDPOINT_NAME_SUFFIX = "WsApi";
  
  /**
   * Used as:
   * <ul>
   * <li>Placeholder in websocket topic patterns defined in value or regexp topic matchers of websocket endpoints,
   * <li>Name of local variable in generated code for websocket endpoint stream topic building.
   * </ul>
   */
  public static final String TOPIC = "topic";

  /**
   * Name of variable holding websocket topic matcher factory instance in
   * generated websocket endpoint classes.
   */
  public static final String WEBSOCKET_TOPIC_MATCHER_FACTORY_VAR_NAME = "topicMatcherFactory";

  /**
   * Generates expected POJO class name for a REST endpoint request POJO.
   * <p>
   * Relevant when request is defined for the endpoint and is of object type (see {@link Type#isObject()}).
   * <p>
   * The package of the generated class is the sub-package <code>pojo</code> of the base package of the exchange descriptor.
   * <ul>
   * <li>If <code>objectName</code> is defined, the generated class simple name is the object name</li>
   * <li>Otherwise, the generated class simple name is the concatenation of the exchange, exchange API, endpoint name and <code>Request</code> suffix</li>
   * </ul>
   * @param exchangeDescriptor      The exchange descriptor
   * @param exchangeApiDescriptor   The exchange API descriptor
   * @param restEndpointDescriptor  The REST endpoint descriptor
   * @return The expected class name for a endpoint request, for instance <code>com.x.y.api.pojo.MyExchangeMyApiMyEndpointRequest</code>
   * @throws IllegalArgumentException if request is not defined for the endpoint or is not of object type (see {@link Type#isObject()})
   */
  public static String generateRestEnpointRequestPojoClassName(ExchangeDescriptor exchangeDescriptor, 
                                  ExchangeApiDescriptor exchangeApiDescriptor, 
                                  RestEndpointDescriptor restEndpointDescriptor) {
    Field request = restEndpointDescriptor.getRequest();
    if (request == null) {
      throw new IllegalArgumentException("No request for endpoint:" + restEndpointDescriptor);
    }
    return generateEnpointPojoClassName(
        exchangeDescriptor, 
        exchangeApiDescriptor, 
        exchangeApiDescriptor.getRestEndpoints()
          .stream()
          .map(RestEndpointDescriptor::getName)
          .toList(),
        restEndpointDescriptor.getName(), 
        request.getType(), 
        request.getObjectName(), 
        "Request");
  }

  /**
   * Generates expected class name for a REST endpoint response POJO.
   * <p>
   * Works similarly to {@link #generateRestEnpointRequestPojoClassName(ExchangeDescriptor, ExchangeApiDescriptor, RestEndpointDescriptor)}, 
   * but using <code>Response</code> as method name suffix.
   * @param exchangeDescriptor      The exchange descriptor
   * @param exchangeApiDescriptor   The exchange API descriptor
   * @param restEndpointDescriptor  The REST endpoint descriptor
   * @return The expected class name for a endpoint response, for instance <code>com.x.y.api.pojo.MyExchangeMyApiMyEndpointResponse</code>
   * @throws IllegalArgumentException If response is not defined for the endpoint or is not of object type (see {@link Type#isObject()})
   */
  public static String generateRestEnpointResponsePojoClassName(
      ExchangeDescriptor exchangeDescriptor, 
      ExchangeApiDescriptor exchangeApiDescriptor, 
      RestEndpointDescriptor restEndpointDescriptor) {
    Field response = restEndpointDescriptor.getResponse();
    if (response == null) {
      throw new IllegalArgumentException("No response for endpoint:" + restEndpointDescriptor);
    }
    return generateEnpointPojoClassName(
      exchangeDescriptor, 
      exchangeApiDescriptor, 
      exchangeApiDescriptor.getRestEndpoints()
        .stream()
        .map(RestEndpointDescriptor::getName)
        .toList(),
      restEndpointDescriptor.getName(), 
      response.getType(), 
      response.getObjectName(), 
      "Response");
  }
  
  /**
   * Generates expected class name for a Websocket endpoint message POJO.
   * <p>
   * Works similarly to {@link #generateRestEnpointRequestPojoClassName(ExchangeDescriptor, ExchangeApiDescriptor, RestEndpointDescriptor)}, 
   * but using <code>Message</code> as method name suffix.
   * @param exchangeDescriptor      The exchange descriptor
   * @param exchangeApiDescriptor   The exchange API descriptor
   * @param websocketApi        The websocket endpoint descriptor
   * @return The expected class name for a endpoint message, for instance <code>com.x.y.api.pojo.MyExchangeMyApiMyEndpointMessage</code>
   * @throws IllegalArgumentException If message is not defined for the endpoint or is not of object type (see {@link Type#isObject()})
   */
  public static String generateWebsocketEndpointMessagePojoClassName(
              ExchangeDescriptor exchangeDescriptor,
              ExchangeApiDescriptor exchangeApiDescriptor, 
              WebsocketEndpointDescriptor websocketApi) {
    Field message = websocketApi.getMessage();
    if (message == null) {
      throw new IllegalArgumentException("No message for endpoint:" + websocketApi);
    }
    return generateEnpointPojoClassName(
      exchangeDescriptor, 
      exchangeApiDescriptor, 
      exchangeApiDescriptor.getWebsocketEndpoints()
        .stream()
        .map(WebsocketEndpointDescriptor::getName)
        .toList(),
      websocketApi.getName(), 
      message.getType(), 
      message.getObjectName(), 
      "Message");
  }
  
  /**
   * Generates expected class name for a websocket endpoint request POJO.
   * <p>
   * Works similarly to {@link #generateRestEnpointRequestPojoClassName(ExchangeDescriptor, ExchangeApiDescriptor, RestEndpointDescriptor)}, 
   * but using <code>Request</code> as method name suffix.
   * @param exchangeDescriptor      The exchange descriptor
   * @param exchangeApiDescriptor   The exchange API descriptor
   * @param websocketApi        The websocket endpoint descriptor
   * @return The expected class name for a endpoint request, for instance <code>com.x.y.api.pojo.MyExchangeMyApiMyEndpointRequest</code>
   * @throws IllegalArgumentException If request is not defined for the endpoint or is not of object type (see {@link Type#isObject()})
   */
  public static String generateWebsocketEndpointRequestPojoClassName(
                ExchangeDescriptor exchangeDescriptor,
                   ExchangeApiDescriptor exchangeApiDescriptor, 
                   WebsocketEndpointDescriptor websocketApi) {
    Field request = websocketApi.getRequest();
    if (request == null) {
      throw new IllegalArgumentException("No request for endpoint:" + websocketApi);
    }
    return generateEnpointPojoClassName(
          exchangeDescriptor, 
          exchangeApiDescriptor,
          exchangeApiDescriptor.getWebsocketEndpoints()
            .stream()
            .map(WebsocketEndpointDescriptor::getName)
            .toList(),
          websocketApi.getName(), 
          request.getType(), 
          request.getObjectName(), 
          "Request");
  }

  private static String generateEnpointPojoClassName(ExchangeDescriptor exchangeDescriptor, 
                             ExchangeApiDescriptor exchangeApiDescriptor, 
                             List<String> allEndpointNames,
                             String endpointName, 
                             Type type,
                             String objectName,
                             String suffix) {
    if (type == null) {
      type = Type.fromTypeName(CanonicalType.OBJECT.name());
    }
    if (!type.isObject())
      throw new IllegalArgumentException("Not an object field type:" + type);
    if (objectName != null) {
      if (JavaCodeGenUtil.isFullClassName(objectName)) {
        return objectName;
      }
      return exchangeDescriptor.getBasePackage() + "." 
          + exchangeApiDescriptor.getName().toLowerCase() + ".pojo." 
          + JavaCodeGenUtil.firstLetterToUpperCase(objectName);
    }
    String exchangeApiDescriptorName = JavaCodeGenUtil.getUniqueCamelCaseVariableNames(
        exchangeDescriptor.getApis()
        .stream().map(ExchangeApiDescriptor::getName).toList(), true)
        .get(exchangeApiDescriptor.getName());
    endpointName = JavaCodeGenUtil.getUniqueCamelCaseVariableNames(allEndpointNames, true).get(endpointName);
    return exchangeDescriptor.getBasePackage() + "." + exchangeApiDescriptor.getName().toLowerCase() + ".pojo."
        + JavaCodeGenUtil.firstLetterToUpperCase(exchangeDescriptor.getId()) 
        + exchangeApiDescriptorName
        + endpointName
        + suffix;
  }
  
  /**
   * @param restEndpointDescriptor REST endpoint
   * @param allRestEndpoints       All REST endpoints of the exchange API,
   * @return Expected name for generated exchange API group interface method for
   *         calling given REST endpoint
   */
  public static String getRestApiMethodName(RestEndpointDescriptor restEndpointDescriptor, List<RestEndpointDescriptor> allRestEndpoints) {
    return getEndpointMethodOrVariableName(restEndpointDescriptor.getName(),
        allRestEndpoints.stream().map(RestEndpointDescriptor::getName).toList(),
        JavaCodeGenUtil::firstLetterToLowerCase);
  }

  /**
   * Generates expected name for a websocket endpoint subscription method
   * 
   * @param websocketEndpointDescriptor The websocket endpoint descriptor
   * @param allWebsocketEndpoints       All websocket endpoints of the exchange
   *                                    API, should not be <code>null</code>
   * @return expected name for a websocket endpoint subscription method, like
   *         <code>subscribeMyEndpoint</code>
   */
  public static String getWebsocketSubscribeMethodName(
      WebsocketEndpointDescriptor websocketEndpointDescriptor, 
      List<WebsocketEndpointDescriptor> allWebsocketEndpoints) {
    return "subscribe" + getEndpointMethodOrVariableName(websocketEndpointDescriptor.getName(),
        allWebsocketEndpoints.stream().map(WebsocketEndpointDescriptor::getName).toList(),
        JavaCodeGenUtil::firstLetterToUpperCase);
  }

  /**
   * Generates expected name for a websocket endpoint unsubscription method
   * 
   * @param websocketEndpointDescriptor The websocket endpoint descriptor
   * @param allWebsocketEndpoints       All websocket endpoints of the exchange
   *                                    API, should not be <code>null</code>
   * @return expected name for a websocket endpoint unsubscription method, like
   *         <code>unsubscribeMyEndpoint</code>
   */
  public static String getWebsocketUnsubscribeMethodName(
      WebsocketEndpointDescriptor websocketEndpointDescriptor, 
      List<WebsocketEndpointDescriptor> allWebsocketEndpoints) {
    return "unsubscribe" + getEndpointMethodOrVariableName(websocketEndpointDescriptor.getName(),
             allWebsocketEndpoints.stream().map(WebsocketEndpointDescriptor::getName).toList(),
             JavaCodeGenUtil::firstLetterToUpperCase);
  }
  
  private static String getEndpointMethodOrVariableName(
      String endpointName, 
      List<String> allEndpointNames, 
      UnaryOperator<String> transformFunction) {
    for (String otherEndpointName : allEndpointNames) {
      if (!Objects.equals(endpointName, otherEndpointName)
          && Objects.equals(transformFunction.apply(endpointName), transformFunction.apply(otherEndpointName))) {
        return endpointName;
      }
    }
    return transformFunction.apply(endpointName);
  }

  /**
   * Checks if given REST endpoint has a request defined, and that request has
   * arguments.
   * 
   * @param restApi               The REST endpoint descriptor
   * @param exchangeApiDescriptor The exchange API descriptor, used to get the
   *                              properties of the response field if it is an
   *                              object type with actual properties defined in
   *                              another API.
   * @return <code>true</code> if the REST endpoint has a response defined, and
   *         that
   *         response is either a primitive type or an object type has at least
   *         one property defined.
   */
  public static boolean restEndpointHasResponse(RestEndpointDescriptor restApi, 
                          ExchangeApiDescriptor exchangeApiDescriptor) {
    Field response = restApi.getResponse();
    if (response == null) {
      return false;
    }
    Type dataType = PojoGenUtil.getFieldType(response);
    return (dataType.getCanonicalType() != CanonicalType.OBJECT) 
        || getFieldPropertiesCount(response, exchangeApiDescriptor) > 0
        || JavaCodeGenUtil.isFullClassName(response.getObjectName());
  }

  /**
   * @param restApi The REST endpoint descriptor
   * @param exchangeApiDescriptor The exchange API descriptor
   * @return <code>true</code> if the REST endpoint has a request defined 
   *       {@link RestEndpointDescriptor#getRequest()}, and that request field has arguments, 
   *       see {@link #endpointHasArguments(Field, ExchangeApiDescriptor)}
   */
  public static boolean restEndpointHasArguments(RestEndpointDescriptor restApi, 
                           ExchangeApiDescriptor exchangeApiDescriptor) {
    Field request = restApi.getRequest();
    if (request == null) {
      return false;
    }
    return endpointHasArguments(request, exchangeApiDescriptor);
  }

  /**
   * @param websocketApi The websocket endpoint descriptor
   * @param exchangeApiDescriptor The exchange API descriptor
   * @return <code>true</code> if the websocket endpoint has a request field defined 
   *       see {@link WebsocketEndpointDescriptor#getRequest()}, and that message field has arguments,
   *       see {@link #endpointHasArguments(Field, ExchangeApiDescriptor)}
   */
  public static boolean websocketEndpointHasArguments(WebsocketEndpointDescriptor websocketApi, 
                            ExchangeApiDescriptor exchangeApiDescriptor) {
    Field request = websocketApi.getRequest();
    if (request == null) {
      return false;
    }
    return endpointHasArguments(request, exchangeApiDescriptor);
  }

  /**
   * @param endpointRequest The endpoint request field
   * @param exchangeApiDescriptor  The exchange API descriptor of the endpoint
   * @return <code>true</code> if the endpoint request is not <code>null</code> and its type has arguments, 
   *       see {@link #endpointHasArguments(Field, ExchangeApiDescriptor)}
   */
  public static boolean endpointHasArguments(Field endpointRequest, 
                         ExchangeApiDescriptor exchangeApiDescriptor) {
    if (endpointRequest == null) {
      return false;
    }
    Type dataType = PojoGenUtil.getFieldType(endpointRequest);
    return (dataType.getCanonicalType() != CanonicalType.OBJECT) 
        || getFieldPropertiesCount(endpointRequest, exchangeApiDescriptor) > 0
        || JavaCodeGenUtil.isFullClassName(endpointRequest.getObjectName());
  }

  /**
   * The name property of Field of a REST request/Websocket subscribe request is
   * used to generate the name of the argument in the generated method signature.
   * <br>
   * If the name property is not defined, the default name
   * {@link #DEFAULT_REQUEST_ARG_NAME} is used.
   * Notice this function argument is used in API interface method declaration,
   * but not in the generated method implementation.
   * This is because the generated method implementation uses a fixed name for the
   * request argument, see {@link #DEFAULT_REQUEST_ARG_NAME}
   * to make sure there is no collising between this name and the other variables
   * used in the generated method implementation or interface implementation
   * class.
   * 
   * @param requestArgNameFromApiDescriptor The name property of the request field of REST request or Websocket subscribe request.
   * @return <code>requestArgNameFromApiDescriptor</code> if not
   *         <code>null</code>, otherwise {@link #DEFAULT_REQUEST_ARG_NAME}
   */
  public static String getRequestArgName(String requestArgNameFromApiDescriptor) {
    return Optional.ofNullable(requestArgNameFromApiDescriptor).orElse(DEFAULT_REQUEST_ARG_NAME);
  }

  /**
   * A given {@link Field} may have an object name defined, see
   * {@link Field#getObjectName()} and properties of this objectName defined in
   * another API of the enclosing ExchangeApi, or it could be the case for some
   * sub-properties defined, see {@link Field#getProperties()}.
   * <br>
   * This method performs a recursive resolution of properties for the given field
   * among all 'object' properties of every REST request or response or Websockey
   * subscribe request and message.
   * <br>
   * If provided {@link Field} has a defined objectName, is of 'object' type (see
   * {@link Type#isObject()}) and has <code>null</code> sub properties then its
   * sub properties are set with ones of first field found in any object field of
   * any
   * REST/Websocket API that has same object name as this field.
   * <br>
   * Same is done for all sub-properties of this field recursively.
   * 
   * @param exchangeApiDescriptor The exchange API descriptor containing the REST
   *                              and Websocket endpoints to search for properties
   *                              of the object name.
   * @param field                 the field to resolve properties for.
   * @return The field with resolved properties. Will be a clone of the input
   *         field if some properties were resolved, or same field if no
   *         properties were resolved.
   * @throws IllegalArgumentException if no properties were found for the object
   *                                  name of the field in the enclosing API.
   */
  public static Field resolveFieldProperties(ExchangeApiDescriptor exchangeApiDescriptor, 
                         Field field) {
     if (field == null) {
      return null;
    }
    Type type = PojoGenUtil.getFieldType(field);
    if (type.isObject()) {
      String objectName = field.getObjectName();
      if (!JavaCodeGenUtil.isFullClassName(objectName)
          && objectName != null
          && field.getProperties() == null) {
        field = field.deepClone();
        field.setType(type);
        field.setProperties(findPropertiesForObjectNameInApi(objectName, exchangeApiDescriptor));
      }
    }
    return field;
  }
  
  /**
   * Counts the number of properties of a field, eventually resolving these
   * properties in enclosing API (see
   * {@link #resolveFieldProperties(ExchangeApiDescriptor, Field)}).
   * 
   * @param field                 The field to count properties of
   * @param exchangeApiDescriptor The enclosing API descriptor to resolve
   *                              properties in
   * @return 0 if field is <code>null</code>, or the number of properties of the
   *         field, eventually resolved in enclosing API.
   */
  public static int getFieldPropertiesCount(Field field, 
                        ExchangeApiDescriptor exchangeApiDescriptor) {
    return Optional.ofNullable(field == null? null: resolveFieldProperties(exchangeApiDescriptor, field).getProperties())
                   .orElse(List.of()).size();
  }

  /**
   * Finds the properties of an object name in an API descriptor: return
   * properties (see {@link Field#getProperties()})
   * of first field found in any object field of any REST/Websocket API that has
   * same object name as this field.
   * 
   * @param requestObjectName     The object name to find properties for.
   * @param exchangeApiDescriptor The API descriptor to search for properties of
   *                              the object name.
   * @return The list of properties of the object name in the API descriptor.
   * @throws IllegalArgumentException if no properties were found for the object
   *                                  name in the enclosing API, or if either
   *                                  <code>requestObjectName</code> or
   *                                  <code>exchangeApiDescriptor</code> is
   *                                  <code>null</code>.
   */
  public static List<Field> findPropertiesForObjectNameInApi(String requestObjectName, 
                                 ExchangeApiDescriptor exchangeApiDescriptor) {
    if (requestObjectName == null) {
      throw new IllegalArgumentException("null objectName");
    }
    if (exchangeApiDescriptor == null) {
      throw new IllegalArgumentException("null exchangeApiDescriptor");
    }
    List<Field> res = null;
    for (RestEndpointDescriptor restEndpointDescriptor: 
        Optional.ofNullable(exchangeApiDescriptor.getRestEndpoints()).orElse(List.of())) {
      res = Optional.ofNullable(PojoGenUtil.findPropertiesForObjectNameInField(requestObjectName, restEndpointDescriptor.getRequest()))
          .orElse(PojoGenUtil.findPropertiesForObjectNameInField(requestObjectName, restEndpointDescriptor.getResponse()));
      if (res != null) {
        break;
      }
    }
    
    if (res == null) {
      for (WebsocketEndpointDescriptor websocketEndpointDescriptor: 
          Optional.ofNullable(exchangeApiDescriptor.getWebsocketEndpoints()).orElse(List.of())) {
        res = Optional.ofNullable(PojoGenUtil.findPropertiesForObjectNameInField(requestObjectName, websocketEndpointDescriptor.getRequest()))
            .orElse(PojoGenUtil.findPropertiesForObjectNameInField(requestObjectName, websocketEndpointDescriptor.getMessage()));
        if (res != null) {
          break;
        }
      }
    }
    
    if (res != null) {
      return resolveAllFieldProperties(exchangeApiDescriptor, res);
    }
    throw new IllegalArgumentException("Found no REST request or response or Websocket request or message with fields defined for objectName:"  
                       + requestObjectName);
  }

  /**
   * Resolves properties of all fields in a list of fields, see
   * {@link #resolveFieldProperties(ExchangeApiDescriptor, Field)}.
   * 
   * @param exchangeApiDescriptor The enclosing API descriptor to resolve
   *                              properties in
   * @param fields                The list of fields to resolve properties for
   * @return The list of fields with resolved properties
   */
  public static List<Field> resolveAllFieldProperties(ExchangeApiDescriptor exchangeApiDescriptor, 
                            List<Field> fields) {
    return fields.stream().map(f -> resolveFieldProperties(exchangeApiDescriptor, f))
                .toList();
  }
  
  /**
   * Generates expected camel case value of varibale name in a generated
   * {@link ExchangeApi} for default value of REST endpoint request.
   * <p>
   * Remark: The actual variable name will be the static variable name generated
   * from this value, respecting uniqueness, see
   * #generateRestEndpointRequestDefaultValuesStaticFieldDeclarations(List,
   * Imports, PlaceHolderResolver, PlaceHolderResolver, StringBuilder)
   * 
   * @param restEndpointDescriptor The REST endpoint descriptor
   * @return The expected static variable name for the REST endpoint request
   *         default value, for instance
   *         <code>myRestEndpointRequestDefaultValue</code>
   */
  public static String getRestEndpointRequestDefaultValueVariableName(RestEndpointDescriptor restEndpointDescriptor) {
    return restEndpointDescriptor.getName() + "RestRequest";
  }
  
  /**
   * Generates expected static variable name in a generated {@link ExchangeApi}
   * for default value of Websocket endpoint request. Remark: The actual variable
   * name will be the static variable name generated from this value, respecting
   * uniqueness, see
   * #generateWebsocketEndpointRequestDefaultValuesStaticFieldDeclarations(List,
   * Imports, PlaceHolderResolver, PlaceHolderResolver, StringBuilder)
   * 
   * @param wsEndpointDescriptor The Websocket endpoint descriptor
   * @return The expected static variable name for the Websocket endpoint request
   *         default value, for instance
   */
  public static String getWebsocketEndpointRequestDefaultValueVariableName(WebsocketEndpointDescriptor wsEndpointDescriptor) {
    return wsEndpointDescriptor.getName() + "WsRequest";
  }
  
  /**
   * Generates static field declarations for default values of REST endpoint
   * requests.
   * 
   * @param restEndpoints                   List of REST endpoint descriptors of a
   *                                        given Exchange API group
   * @param imports                         The imports of generator context that
   *                                        will be populated with classes used by
   *                                        generated fields.
   * @param docPlaceHolderResolver          Resolver for placeholders in javadoc
   * @param defaultValuePlaceHolderResolver Resolver for constants placeholders in
   *                                        default values
   * @param classBody                       StringBuilder to append generated
   *                                        field declarations to. Can be null, in
   *                                        which case no field declarations are
   *                                        appended and associated imports not
   *                                        added to import list.
   * @return Map indexed with
   *         {@link #getRestEndpointRequestDefaultValueVariableName(RestEndpointDescriptor)}
   *         for each REST endpoint which request has a default value, mapped to
   *         associated static variable name.
   */
  public static Map<String, String> generateRestEndpointRequestDefaultValuesStaticFieldDeclarations(
      List<RestEndpointDescriptor> restEndpoints, 
      Imports imports, 
      PlaceHolderResolver docPlaceHolderResolver, 
      PlaceHolderResolver defaultValuePlaceHolderResolver,
      StringBuilder classBody) {
    List<Field> fields = restEndpoints.stream()
        .filter(r -> r.getRequest() != null 
                    && r.getRequest().getDefaultValue() != null)
        .map(r -> {
          Field clone = r.getRequest().deepClone();
          clone.setName(getRestEndpointRequestDefaultValueVariableName(r));
          return clone;
        })
        .toList();
    return PojoGenUtil.generateDefaultValuesStaticFieldDeclarations(
        fields, 
        imports, 
        docPlaceHolderResolver, 
        defaultValuePlaceHolderResolver, 
        classBody);  
  }
  
  /**
   * Generates static field declarations for default values of REST endpoint
   * requests.
   * 
   * @param wsEndpoints                     List of webscoket endpoint descriptors of a
   *                                        given Exchange API group
   * @param imports                         The imports of generator context that
   *                                        will be populated with classes used by
   *                                        generated fields.
   * @param docPlaceHolderResolver          Resolver for placeholders in javadoc
   * @param defaultValuePlaceHolderResolver Resolver for constants placeholders in
   *                                        default values
   * @param classBody                       StringBuilder to append generated
   *                                        field declarations to. Can be null, in
   *                                        which case no field declarations are
   *                                        appended and associated imports not
   *                                        added to import list.
   * @return Map indexed with
   *         {@link #getWebsocketEndpointRequestDefaultValueVariableName(WebsocketEndpointDescriptor)}
   *         for each websocket endpoint which request has a default value, mapped to
   *         associated static variable name.
   */
  public static Map<String, String> generateWebsocketEndpointRequestDefaultValuesStaticFieldDeclarations(
      List<WebsocketEndpointDescriptor> wsEndpoints, 
      Imports imports, 
      PlaceHolderResolver docPlaceHolderResolver, 
      PlaceHolderResolver defaultValuePlaceHolderResolver,
      StringBuilder classBody) {
    List<Field> fields = wsEndpoints.stream()
        .filter(r -> r.getRequest() != null 
                    && r.getRequest().getDefaultValue() != null)
        .map(r -> {
          Field clone = r.getRequest().deepClone();
          clone.setName(getWebsocketEndpointRequestDefaultValueVariableName(r));
          return clone;
        })
        .toList();
    return PojoGenUtil.generateDefaultValuesStaticFieldDeclarations(
        fields, 
        imports, 
        docPlaceHolderResolver, 
        defaultValuePlaceHolderResolver, 
        classBody);  
  }
  
  /**
   * Generates the declaration of a websocket topic matcher factory for a given
   * endpoint. The generated instruction is declaration of a local variable named
   * {@link #WEBSOCKET_TOPIC_MATCHER_FACTORY_VAR_NAME}, and a value initialized
   * with call to {@link WSMTMFUtil} static methods to create the topic matcher
   * factory.
   * 
   * @param exchangeDescriptor    The exchange descriptor
   * @param exchangeApiDescriptor The exchange API descriptor
   * @param websocketApi          The websocket endpoint descriptor
   * @param imports               The imports of generator context that will be
   *                              populated with classes used by generated fields.
   * @return The websocket topic matcher factory declaration instruction.
   */
  public static String generateWebsocketTopicMatcherFactoryDeclaration(
      ExchangeDescriptor exchangeDescriptor,
      ExchangeApiDescriptor exchangeApiDescriptor,
      WebsocketEndpointDescriptor websocketApi, 
      Imports imports) {
    imports.add(WebsocketMessageTopicMatcherFactory.class);
    Field request = ExchangeApiGenUtil.resolveFieldProperties(exchangeApiDescriptor, websocketApi.getRequest());
    Field message = ExchangeApiGenUtil.resolveFieldProperties(exchangeApiDescriptor, websocketApi.getMessage());
    return new StringBuilder()
        .append(WebsocketMessageTopicMatcherFactory.class.getSimpleName())
        .append(" ")
        .append(WEBSOCKET_TOPIC_MATCHER_FACTORY_VAR_NAME)
        .append(" = ")
        .append(generateWebsocketTopicMatcherFactoryDeclaration(
            exchangeDescriptor, 
            exchangeApiDescriptor, 
            websocketApi, 
            request,
            message,
            imports, 
            websocketApi.getTopicMatcher()))
        .append(";").toString();
  }
  
  private static String generateWebsocketTopicMatcherFactoryDeclaration(
      ExchangeDescriptor exchangeDescriptor,
      ExchangeApiDescriptor exchangeApiDescriptor,
      WebsocketEndpointDescriptor websocketApi, 
      Field request, 
      Field message,
      Imports imports,
      WebsocketTopicMatcherDescriptor topicMatcherDescriptor) {
    checkValidWebsocketTopicMatcherDescriptor(
        exchangeDescriptor.getId(), 
        exchangeApiDescriptor.getName(),
        websocketApi.getName(), 
        topicMatcherDescriptor);
    if (topicMatcherDescriptor == null) {
      imports.add(WebsocketMessageTopicMatcherFactory.class);
      return WebsocketMessageTopicMatcherFactory.class.getSimpleName() + ".ANY_MATCHER_FACTORY";
    }
    imports.add(WSMTMFUtil.class);
    StringBuilder declaration = new StringBuilder()
        .append(WSMTMFUtil.class.getSimpleName())
        .append(".");
    if (topicMatcherDescriptor.getFieldName() != null) {
      Object value = topicMatcherDescriptor.getFieldValue();
      if (topicMatcherDescriptor.getFieldValue() != null) {
        declaration.append("value(");
      } else { // fieldRegexp
        declaration.append("regexp(");
        value = topicMatcherDescriptor.getFieldRegexp();
      }
      declaration
        .append(JavaCodeGenUtil.getQuotedString(
            PojoGenUtil.getMsgFieldName(topicMatcherDescriptor.getFieldName(), message)))
        .append(", ")
        .append(generateTopicMatcherValueSubstitutionInstructionDeclaration(
          value, 
          exchangeDescriptor, 
          request, 
          imports))
      .append(")");
    } else {
      imports.add(WSMTMFUtil.class);
      imports.add(List.class);
      List<WebsocketTopicMatcherDescriptor> subMatchers = null;
      if (topicMatcherDescriptor.getAnd() != null) {
        declaration.append("and(List.of(\n");
        subMatchers = topicMatcherDescriptor.getAnd();
      } else { // or
        declaration.append("or(List.of(\n");
        subMatchers = topicMatcherDescriptor.getOr();
      }
      for (int i = 0; i < subMatchers.size(); i++) {
        if (i > 0) {
          declaration.append(",\n");
        }
        declaration.append(JavaCodeGenUtil.indent(
            generateWebsocketTopicMatcherFactoryDeclaration(
              exchangeDescriptor, 
              exchangeApiDescriptor, 
              websocketApi,
              request, 
              message,
              imports, 
              subMatchers.get(i))));
      }
      declaration.append("))");
    }
    return declaration.toString();
  }
  
  /**
   * Checks if given websocket topic matcher descriptor is valid. For a given
   * topic matcher descriptor, exactly one of the following must be true:
   * <ul>
   * <li>fieldName is defined, and either fieldValue or fieldRegexp is
   * defined</li>
   * <li>'and' operator is defined with a list of sub-matchers</li>
   * <li>'or' operator is defined with a list of sub-matchers</li>
   * </ul>
   * 
   * @param exchangeId             Exchange identifier see
   *                               {@link ExchangeDescriptor#getId()}
   * @param apiName                API name, see
   *                               {@link ExchangeApiDescriptor#getName()}
   * @param endpointName           Websocket endpoint name, see
   *                               {@link WebsocketEndpointDescriptor#getName()}
   * @param topicMatcherDescriptor The websocket topic matcher descriptor to
   *                               check, can be <code>null</code>, otherwise has
   *                               to enforce above rules.
   */
  public static void checkValidWebsocketTopicMatcherDescriptor(
      String exchangeId, 
      String apiName, 
      String endpointName, 
      WebsocketTopicMatcherDescriptor topicMatcherDescriptor) {
    if (topicMatcherDescriptor == null) {
      return;
    }
    
    if (checkFieldValueTopicMatcherDescriptor(
        exchangeId, 
        apiName, 
        endpointName, 
        topicMatcherDescriptor)) {
      return;
    }
    
    if (checkAndTopicMatcherDescriptorValidity(
        exchangeId, 
        apiName, 
        endpointName, 
        topicMatcherDescriptor)) {
      return;
    }
    
    if (checkOrTopicMatcherDescriptorValidity(
        exchangeId, 
        apiName, 
        endpointName, 
        topicMatcherDescriptor)) {
      return;
    }
    
    throw new IllegalArgumentException(
        INVALID_TOPIC_MATCHER_FOR_WEBSOCKET_ENDPOINT + endpointName + OF_EXCHANGE_API + apiName
            + OF_EXCHANGE + exchangeId + ": either fieldName, 'and' or 'or' operator must be defined");
  }
  
  private static boolean checkFieldValueTopicMatcherDescriptor(
      String exchangeId, 
      String apiName, 
      String endpointName, 
      WebsocketTopicMatcherDescriptor topicMatcherDescriptor) {
    if (topicMatcherDescriptor.getFieldName() != null) {
      if (topicMatcherDescriptor.getAnd() != null) {
        throw new IllegalArgumentException(
            INVALID_TOPIC_MATCHER_FOR_WEBSOCKET_ENDPOINT + endpointName + OF_EXCHANGE_API + apiName
                + OF_EXCHANGE + exchangeId + ": fieldName cannot be defined with 'and' operator");
      }
      if (topicMatcherDescriptor.getOr() != null) {
        throw new IllegalArgumentException(
            INVALID_TOPIC_MATCHER_FOR_WEBSOCKET_ENDPOINT + endpointName + OF_EXCHANGE_API + apiName
                + OF_EXCHANGE + exchangeId + ": fieldName cannot be defined with 'or' operator");
      }
      if (topicMatcherDescriptor.getFieldRegexp() == null && topicMatcherDescriptor.getFieldValue() == null) {
        throw new IllegalArgumentException(INVALID_TOPIC_MATCHER_FOR_WEBSOCKET_ENDPOINT + endpointName
            + OF_EXCHANGE_API + apiName + OF_EXCHANGE + exchangeId
            + ": fieldName must be associated with either fieldValue or fieldRegexp");
      }
      return true;
    } 
    return false;
  }
  
  private static boolean checkAndTopicMatcherDescriptorValidity(
      String exchangeId, 
      String apiName, 
      String endpointName, 
      WebsocketTopicMatcherDescriptor topicMatcherDescriptor) {
    if (topicMatcherDescriptor.getAnd() != null) {
      if (topicMatcherDescriptor.getOr() != null) {
        throw new IllegalArgumentException(
            INVALID_TOPIC_MATCHER_FOR_WEBSOCKET_ENDPOINT + endpointName + OF_EXCHANGE_API + apiName
                + OF_EXCHANGE + exchangeId + ": 'and' and 'or' operators cannot be defined together");
      }
      if (topicMatcherDescriptor.getFieldValue() != null || topicMatcherDescriptor.getFieldRegexp() != null) {
        throw new IllegalArgumentException(
            INVALID_TOPIC_MATCHER_FOR_WEBSOCKET_ENDPOINT + endpointName + OF_EXCHANGE_API + apiName
                + OF_EXCHANGE + exchangeId + ": 'and' operator cannot be defined with fieldValue or fieldRegexp");
      }
      topicMatcherDescriptor.getAnd().forEach(
          subMatcher -> checkValidWebsocketTopicMatcherDescriptor(exchangeId, apiName, endpointName, subMatcher));
      return true;
    }
    return false;
  }
  
  private static boolean checkOrTopicMatcherDescriptorValidity(
      String exchangeId, 
      String apiName, 
      String endpointName, 
      WebsocketTopicMatcherDescriptor topicMatcherDescriptor) {
    if (topicMatcherDescriptor.getOr() != null) {
      if (topicMatcherDescriptor.getFieldValue() != null || topicMatcherDescriptor.getFieldRegexp() != null) {
        throw new IllegalArgumentException(
            INVALID_TOPIC_MATCHER_FOR_WEBSOCKET_ENDPOINT + endpointName + OF_EXCHANGE_API + apiName
                + OF_EXCHANGE + exchangeId + ": 'and' operator cannot be defined with fieldValue or fieldRegexp");
      }
      topicMatcherDescriptor.getOr().forEach(
          subMatcher -> checkValidWebsocketTopicMatcherDescriptor(exchangeId, apiName, endpointName, subMatcher));
      return true;
    }
    return false;
  }
  
  /**
   * Generates Java code declaration for topic value substitution instruction
   * for a given template.
   * <p>
   * If template has no placeholders, the quoted string of the template is
   * returned.
   * <p>
   * Otherwise, the instruction to substitute arguments in the template is
   * returned, using {@link EncodingUtil#substituteArguments(String, String...)}.
   * <p>
   * Each placeholder value is generated using by following rules:
   * <ul>
   * <li>If placeholder is a constant placeholder, see {@link ExchangeGenUtil#CONSTANT_PLACEHOLDER_PREFIX},
   * the value is generated using {@link ExchangeGenUtil#getValueDeclarationForConstant(String, ExchangeDescriptor, Imports)},
   * e.g. value used is reference from exchange's constants class corresponding constant</li>
   * <li>If placeholder is a config property placeholder, see {@link ExchangeGenUtil#CONFIG_PLACEHOLDER_PREFIX},
   * the value is generated using {@link ExchangeGenUtil#getValueDeclarationForConfigProperty(String, ExchangeDescriptor, List, String, Imports)},
   * e.g. value used is reference from exchange's config properties</li>
   * <li>If placeholder is a request field placeholder, starting with {@link #DEFAULT_REQUEST_ARG_NAME},
   * the value is generated using:
   * <ul>
   * <li>if placeholder is exactly {@link #DEFAULT_REQUEST_ARG_NAME}, the value is the request argument itself</li>
   * <li>if placeholder is like <code>request.subField1.subField2...</code>, the value generated is call
   * to get sub-field value from request argument</li>
   * </ul>
   * </li>
   * </ul>
   * @param value The topic template with placeholders
   * @param exchangeDescriptor The exchange descriptor to get constants and config properties from
   * @param request The websocket subscribe request field
   * @param imports The imports of generator context that will be populated with classes used by returned declaration.
   * @return Java code declaration for topic value substitution
   */
  public static String generateTopicValueSubstitutionInstructionDeclaration(
      Object value,
      ExchangeDescriptor exchangeDescriptor,
      Field request,
      Imports imports) {
    return generateTopicValueSubstitutionInstructionDeclaration(value, exchangeDescriptor, request, imports, false);
  }

  /**
   * Generates Java code declaration for topic matcher value substitution
   * instruction for a given template.
   * <p>
   * If template has no placeholders, the quoted string of the template is
   * returned.
   * <p>
   * Otherwise, the instruction to substitute arguments in the template is
   * returned, using {@link EncodingUtil#substituteArguments(String, String...)}.
   * <p>
   * Each placeholder value is generated using by following rules:
   * <ul>
   * <li>If placeholder is <code>topic</code>, the value is the local variable
   * 'topic' see {@link #TOPIC}</li>
   * <li>If placeholder is a constant placeholder, see
   * {@link ExchangeGenUtil#CONSTANT_PLACEHOLDER_PREFIX}, the value is generated
   * using
   * {@link ExchangeGenUtil#getValueDeclarationForConstant(String, ExchangeDescriptor, Imports)},
   * e.g. value used is reference from exchange's constants class corresponding
   * constant</li>
   * <li>If placeholder is a config property placeholder, see
   * {@link ExchangeGenUtil#CONFIG_PLACEHOLDER_PREFIX}, the value is generated
   * using
   * {@link ExchangeGenUtil#getValueDeclarationForConfigProperty(String, ExchangeDescriptor, List, String, Imports)},
   * e.g. value used is reference from exchange's config properties</li>
   * <li>If placeholder is a request field placeholder, starting with
   * {@link #DEFAULT_REQUEST_ARG_NAME}, the value is generated using:
   * <ul>
   * <li>if placeholder is exactly {@link #DEFAULT_REQUEST_ARG_NAME}, the value is
   * the request argument itself</li>
   * <li>if placeholder is like <code>request.subField1.subField2...</code>, the
   * value generated is call to get sub-field value from request argument</li>
   * </ul>
   * </li>
   * </ul>
   * <p>
   * Remark: This method behaves like
   * {@link #generateTopicValueSubstitutionInstructionDeclaration(Object, ExchangeDescriptor, Field, Imports)}
   * but also supports <code>topic</code> placeholder.
   * 
   * @param value              Either a String containing the topic matcher
   *                           template with placeholders, or primitive value to
   *                           be returned as String.
   * @param exchangeDescriptor The exchange descriptor to get constants and config
   *                           properties from
   * @param request            The websocket subscribe request field
   * @param imports            The imports of generator context that will be
   *                           populated with classes used by returned
   *                           declaration.
   * @return Java code declaration for topic matcher value substitution
   */
  public static String generateTopicMatcherValueSubstitutionInstructionDeclaration(
      Object value,
      ExchangeDescriptor exchangeDescriptor,
      Field request,
      Imports imports) {
    return generateTopicValueSubstitutionInstructionDeclaration(value, exchangeDescriptor, request, imports, true);
  }
  
  private static String generateTopicValueSubstitutionInstructionDeclaration(
      Object value,
      ExchangeDescriptor exchangeDescriptor,
      Field request,
      Imports imports,
      boolean topicMatcher) {
    if (value == null) {
      return null;
    }
    if (!(value instanceof String)) {
      return String.valueOf(value);
    }
    String template = (String) value;
    List<String> placeHolderNames = JavaCodeGenUtil.findPlaceHolders(template);
    if (placeHolderNames.isEmpty()) {
      return JavaCodeGenUtil.getQuotedString(template);
    }
    List<String> placeHoldersDeclarations = new ArrayList<>(placeHolderNames.size());
    for (String placeHolder : placeHolderNames) {
      String valueDeclaration = generateTopicMatcherPlaceHolderValueSubstitution(
          placeHolder, 
          exchangeDescriptor,
          request, 
          imports,
          topicMatcher);
      if (valueDeclaration != null) {
        placeHoldersDeclarations.add(JavaCodeGenUtil.getQuotedString(placeHolder));
        placeHoldersDeclarations.add(valueDeclaration);
      }
    }
    imports.add(EncodingUtil.class);
    return new StringBuilder()
        .append(EncodingUtil.class.getSimpleName())
        .append(".substituteArguments(")
        .append(JavaCodeGenUtil.getQuotedString(template))
        .append(", ")
        .append(StringUtils.join(placeHoldersDeclarations, ", "))
        .append(")")
        .toString();
  }
  
  
  
  private static final String generateTopicMatcherPlaceHolderValueSubstitution(
      String placeHolder,
      ExchangeDescriptor exchangeDescriptor,
      Field request,
      Imports imports,
      boolean topicMatcher) {
    if (placeHolder.equals(TOPIC)) {
      if (!topicMatcher) {
        throw new IllegalArgumentException("'topic' placeholder is only allowed in websocket topic matcher templates");
      }
      // Topic placeholder: There is a local variable 'topic' in the
      // generated subscribe method which holds the actual topic value.
      return TOPIC;
    }
    if (placeHolder.startsWith(ExchangeGenUtil.CONSTANT_PLACEHOLDER_PREFIX)) {
      return ExchangeGenUtil.getValueDeclarationForConstant(
          ExchangeGenUtil.getConstantPlaceHolder(placeHolder), 
          exchangeDescriptor, 
          imports);
    } else if (placeHolder.startsWith(ExchangeGenUtil.CONFIG_PLACEHOLDER_PREFIX)) {
      return ExchangeGenUtil.getValueDeclarationForConfigProperty(
          ExchangeGenUtil.getConfigPropertyPlaceHolder(placeHolder), 
          exchangeDescriptor, 
          null, 
          "getProperties()", 
          imports);
    } else if (placeHolder.startsWith(DEFAULT_REQUEST_ARG_NAME)) {
      return generateValueDeclarationForRequestPlaceholder(placeHolder, request, imports);
    }
    return null;
  }
  
  /**
   * Generates Java code declaration to get value for a given request field.
   * <p>
   * The requestFieldPlaceHolder is expected to be either <code>request</code>,
   * that is the default request argument name, hence the full request object, or
   * a sub-field of the request, like <code>request.subField1.subField2...</code>.
   * 
   * @param requestFieldPlaceHolder The request field placeholder to generate
   *                                value declaration for.
   * @param requestField            The request field descriptor.
   * @param imports                 The imports of generator context that will be
   *                                populated with classes used by returned
   *                                declaration.
   * @return Java code declaration to get value for given request field.
   */
  public static String generateValueDeclarationForRequestPlaceholder(
      String requestFieldPlaceHolder, 
      Field requestField, 
      Imports imports) {
    Type type = PojoGenUtil.getFieldType(requestField);
    List<Field> properties = CollectionUtil.emptyIfNull(requestField.getProperties());
    StringBuilder declaration = new StringBuilder();
    declaration.append(DEFAULT_REQUEST_ARG_NAME);
    if (!DEFAULT_REQUEST_ARG_NAME.equals(requestFieldPlaceHolder)) {
      // placeholder is like request.subField1.subField2...
      String[] parts = requestFieldPlaceHolder.split("\\.");
      for (int i = 1; i < parts.length; i++) {
        declaration.append(".");
        String part = parts[i];
        Field sub = CollectionUtil.emptyIfNull(properties).stream()
          .filter(f -> f.getName().equals(part))
          .findFirst()
          .orElseThrow(() -> new IllegalArgumentException(
             "No property named:" 
               + part 
               + " found in request field for placeholder:" 
               + requestFieldPlaceHolder));
        type = PojoGenUtil.getFieldType(sub);
        declaration.append(JavaCodeGenUtil.getGetAccessorMethodName(
            sub.getName(),
            type,
            properties.stream().map(Field::getName).toList())).append("()");
        properties = CollectionUtil.emptyIfNull(sub.getProperties());
      }
    } 
    String res = declaration.toString();
    if (type.getCanonicalType() == CanonicalType.LIST 
        || type.getCanonicalType() == CanonicalType.MAP
        || type.isObject()) {
      imports.add(JsonUtil.class);
      res = new StringBuilder()
          .append("JsonUtil.pojoToJsonString(")
          .append(res)
          .append(")")
          .toString();
    }
    return res;
  }
  
  /**
   * Creates a default raw body REST request field.
   * When an enpoint does not define a request field, but request has a body,
   * which is the case of HTTP methods like POST, PUT, PATCH, or when REST endpoint
   * <code>requestHasBody</code> is set to true, then a default String parameter
   * is defined on enpoint method to allow passing the raw body of the request.
   * @return A Field of string type named 'body' with description 'Raw body
   *         request field.'
   */
  public static final Field createDefaultRawBodyRequest() {
    return Field.builder()
        .name(RAW_BODY_REST_REQUEST_ARG_NAME)
        .type(Type.STRING)
        .description("Raw body request field.")
        .build();
  }
  
  /**
   * Determines if a REST endpoint has a body in its request.
   * <p>
   * If {@link RestEndpointDescriptor#isRequestHasBody()} is defined, its value is
   * returned.
   * <p>
   * Otherwise, the default behavior is applied based on HTTP method of the
   * endpoint: for HTTP methods POST, PUT, PATCH, the request has body, for other
   * HTTP methods it has not.
   * 
   * @param restApi The REST endpoint descriptor
   * @return <code>true</code> if the REST endpoint request has a body.
   */
  public static boolean restEndpointRequestHasBody(RestEndpointDescriptor restApi) {
    return Optional
        .ofNullable(restApi.isRequestHasBody())
        .orElse(HttpMethod.valueOf(restApi.getHttpMethod()).requestHasBody);
  }

}
